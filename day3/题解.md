
## 1381.[设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)
### 题目
请你设计一个支持下述操作的栈。
实现自定义栈类 CustomStack ：
- CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。
- void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。
- int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。
- void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。
 
### 示例：
```
输入：
["CustomStack","push","push","pop","push","push","push","increment","increment","pop","pop","pop","pop"]
[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]
输出：
[null,null,null,2,null,null,null,null,null,103,202,201,-1]
解释：
CustomStack customStack = new CustomStack(3); // 栈是空的 []
customStack.push(1); // 栈变为 [1]
customStack.push(2); // 栈变为 [1, 2]
customStack.pop(); // 返回 2 --> 返回栈顶值 2，栈变为 [1]
customStack.push(2); // 栈变为 [1, 2]
customStack.push(3); // 栈变为 [1, 2, 3]
customStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4
customStack.increment(5, 100); // 栈变为 [101, 102, 103]
customStack.increment(2, 100); // 栈变为 [201, 202, 103]
customStack.pop(); // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]
customStack.pop(); // 返回 202 --> 返回栈顶值 202，栈变为 [201]
customStack.pop(); // 返回 201 --> 返回栈顶值 201，栈变为 []
customStack.pop(); // 返回 -1 --> 栈为空，返回 -1
```
### 提示：
- 1 <= maxSize <= 1000
- 1 <= x <= 1000
- 1 <= k <= 1000
- 0 <= val <= 100
每种方法 increment，push 以及 pop 分别最多调用 1000 次

### 代码思路
可以用线性表来实现栈，只需要维护一个top指针，指向栈顶。使用动态数组vector<int> s来模拟栈，top指向数组末尾元素的下一个位置。
- push():当top<s.size() s[top]=x,top++
- pop():if top>0 return s[--top]
- increment():n=min(top,k),遍历数组，for j in range(0,n)s[j]+=val
 
```c++
class CustomStack {
public:
    vector<int> stack;
    int max,top=0;         //max保存栈中最多能容纳的元素数量，top表示栈顶元素的位置
    CustomStack(int maxSize) {
        max=maxSize;      
        stack.resize(maxSize);    
    }
    
    void push(int x) {
        if(top<max) 
        {
            stack[top]=x;
            top++;
        }
    }
    
    int pop() {
        if(top>0) 
        {
            return stack[--top];
        }
        else return -1;
    }
    
    void increment(int k, int val) {
        int n=k>top?top:k;
        for(int j=0;j<n;j++)
        {
            stack[j]+=val;
        }
    }
};
```
#### 复杂度分析
- 时间复杂度:O(n)
- 空间复杂度:O(n)

## 287.[寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)
### 题目
 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

### 示例 1:
```
输入: [1,3,4,2,2]
输出: 2
```
### 示例 2:
```
输入: [3,1,3,4,2]
输出: 3
```
### 说明：
- 不能更改原数组（假设数组是只读的）。
- 只能使用额外的 O(1) 的空间。
- 时间复杂度小于 O(n2) 。
- 数组中只有一个重复的数字，但它可能不止重复出现一次。

### 代码思路
本题是典型的双指针解法，与链表是否有环类似，定义两个指针，fast每次走两步，slow每次走一步。
```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow=0,fast=0;   //双指针
        while(1)
        {
            slow=nums[slow];
            fast=nums[nums[fast]];
            if(slow==fast) break;
        }
        slow=0;
        while(1)
        {
            slow=nums[slow];
            fast=nums[fast];
            if(slow==fast) break;
        }
        return slow;
    }
};
```
#### 复杂度分析
- 时间复杂度:最好为O(1)，最坏为![](https://latex.codecogs.com/gif.latex?O%28n%5E2%29)
- 空间复杂度:O(1)


