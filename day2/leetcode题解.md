## 75.[颜色分类](https://leetcode-cn.com/problems/sort-colors/)
### 题目
给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**注意:**
不能使用代码库中的排序函数来解决这道题。

### 示例 
```
输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```
### 进阶
- 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
- 你能想出一个仅使用常数空间的一趟扫描算法吗？

### 方法1
#### 代码思路
通过提示使用计数排序的两趟扫描法，本质上有点类似桶排序。因为只有三种元素，且已知大小，所以只需要三个桶，建立一个长度为3的数组。
遍历所给的数组，完成桶的构造。最后遍历桶中元素值，按照0,1,2元素的个数给数组赋值。
```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
       //计数排序法，两趟扫描
       int count[3]={0};
        for(int a : nums)   //构造桶
        {
            count[a]+=1;
        }
        for(int i=0,j=0;i<3;i++)  //遍历桶，给原有数组重新赋值
        {
            int num=count[i];
            while(num--)
            {   
                nums[j]=i;
                j++;
            }
        }
     }
};
```
#### 复杂度分析
- 时间复杂度：两次扫描花费时间相同。O(n)+O(n)=O(n).
- 空间复杂度:O(1)
### 方法2
#### 代码思路
采用双（3）指针思想，用i遍历数组，将0全部放到数组左边，2全部放到数组右边。left指向已排序完数组0的右端点，right指向1的左端点。
在区间[0,left)都是0，区间(right,len]全部为2.
```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {        
        //双指针，一趟扫描
        int i=0,left=0,right=nums.size()-1;
        
        while(i!=right+1)
        {
            int cur=nums[i];
            if(cur==0)
            {
                swap(nums[left],nums[i]);
                left++;i++;
            }
            else if(cur==1)
            {
                i++;
            }
            else 
            {
                swap(nums[right],nums[i]);
                right--;
            }
        }
    }
};
```
#### 复杂度分析
- 时间复杂度：O(n)，只需要一次扫描。
- 空间复杂度:O(1)
