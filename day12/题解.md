[146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/submissions/)
## 思路
看到key,value想到的就是用哈希表来存储，这样查找的时间复杂度就是O(1),题目需要着重考虑是删除或修改最少使用频率，一开始先想到的是用哈希表存数据，队列存取顺序，但是队列修改的时间复杂度为O(n)，最后看题解是用双向链表+哈希表，一种是使用list，将最近访问过的节点放到开头,另外也可以手写双向链表（明天补上）
- 时间复杂度：O(1)
- 空间复杂度：O(n)，n<=capacity
```c++
class LRUCache {
public:
        list<pair<int,int>> l;
        unordered_map<int,list<pair<int,int>>::iterator> m;
        int size=0;
    LRUCache(int capacity) {
        size=capacity;
    }
      
    int get(int key) {
        if(m.find(key)!=m.end()) 
        {
            int value=m[key]->second;
            l.erase(m[key]);
            l.push_front(make_pair(key, value));
            m[key]=l.begin();
            return value;
        }
        else return -1;
    }
    
    void put(int key, int value) {
        if(m.find(key)==m.end())
        {
            if(m.size()>=size) 
            {
                m.erase(l.back().first);
                l.pop_back();
            }
            l.push_front(make_pair(key, value));
            m[key] = l.begin();
        }
        else{
            l.erase(m[key]);
            l.push_front(make_pair(key,value));
            m[key]=l.begin();
        }
    }
};

```
